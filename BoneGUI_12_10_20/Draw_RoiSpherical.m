%% Draw_RoiSpherical(RoiKind,RoiPosition,color)%% mida group http://mida.dima.unige.it - 2010/2015%%%% this function draws spherical roi%%%% and stores RoiRegion in the struct ROI thorugh the functions%%%% Store_roiRemove(q,varargin) and Store_roi(q,varargin)%%%% called by: Slider_Image()%%%%            PopUp_Districts()%%%% call: Store_roi_sphere(p,varargin) (included in this file, from row 50)%%%%function[]  =  Draw_RoiSpherical(RoiKind,RoiPosition,color)global pet_gui;global Info;global ROI;Delta = (Info.SliceThicknessCT(pet_gui.SelectedCT)/Info.PixelSpacingCT{pet_gui.SelectedCT}(1));if nargin<3, color = 'green'; endh  =  feval(RoiKind,pet_gui.PANELax.ax,RoiPosition);setColor(h,color);fcn  =  makeConstrainToRectFcn(RoiKind,[0.5 512.5],[0.5 512.5]);setPositionConstraintFcn(h,fcn);setFixedAspectRatioMode(h,1);api  =  iptgetapi(h);% current roi numberval = pet_gui.PopupValue;it_star = pet_gui.SliceNumber-ROI{val}.CenterCt;Store_roi_shpere(RoiPosition);api.addNewPositionCallback(@(p) Store_roi_shpere(p));function Store_roi_shpere(p,varargin)    R_star = p(3)./2;    aux = floor(sqrt((R_star^2+(it_star*Delta)^2)/Delta^2));    it = (-aux : 1 : aux)';    R = sqrt(R_star.^2+(it_star.^2-it.^2).*Delta.^2);    p_R = repmat(p(1:2),size(R,1),1)+R_star-[R,R];    ROI{val}.RoiKind = replicate({'imellipse'},1,size(R,1));    ROI{val}.RoiSlice = it + ROI{val}.CenterCt;    ROI{val}.RoiPosition = mat2cell([p_R,2*R,2*R],ones(1,size(R,1)),4);    ROI{val}.StartCt = ROI{val}.RoiSlice(1);    ROI{val}.EndCt = ROI{val}.RoiSlice(end);    if ~isempty(pet_gui.SelectedPT)        AuxPTStart = round((Info.LocationCT{pet_gui.SelectedCT}(ROI{val}.StartCt) - Info.InterceptPT(pet_gui.SelectedPT))./Info.SlopePT(pet_gui.SelectedPT));        if AuxPTStart <= 0, AuxPTStart = 1; end        AuxPTEnd = round((Info.LocationCT{pet_gui.SelectedCT}(ROI{val}.EndCt) - Info.InterceptPT(pet_gui.SelectedPT))./Info.SlopePT(pet_gui.SelectedPT));        %daniela        if ~isempty(ROI{val}.RoiSlicePT) && ~isempty(Info.LocationPT{pet_gui.SelectedPT}) && AuxPTEnd > size(Info.LocationPT{pet_gui.SelectedPT},1)            AuxPTEnd = size(Info.LocationPT{pet_gui.SelectedPT},1);        end        % end daniela        ROI{val}.RoiSlicePT = (AuxPTStart:1:AuxPTEnd);        ROI{val}.RoiSlicePTvsCT = round((Info.LocationPT{pet_gui.SelectedPT}(ROI{val}.RoiSlicePT) - Info.InterceptCT(pet_gui.SelectedCT))./Info.SlopeCT(pet_gui.SelectedCT));        [~,ROI{val}.RoiSlicePTvsCTindex] = ismember(ROI{val}.RoiSlicePTvsCT,ROI{val}.RoiSlice);    end    if ~isempty(pet_gui.SelectedNM)        AuxNMStart = round((Info.LocationCT{pet_gui.SelectedCT}(ROI{val}.StartCt) - Info.InterceptNM(pet_gui.SelectedNM))./Info.SlopeNM(pet_gui.SelectedNM));        AuxNMEnd = round((Info.LocationCT{pet_gui.SelectedCT}(ROI{val}.EndCt) - Info.InterceptNM(pet_gui.SelectedNM))./Info.SlopeNM(pet_gui.SelectedNM));        ROI{val}.RoiSliceNM = (AuxNMStart:1:AuxNMEnd);        ROI{val}.RoiSliceNMvsCT = round((Info.LocationNM{pet_gui.SelectedNM}(ROI{val}.RoiSliceNM) - Info.InterceptCT(pet_gui.SelectedCT))./Info.SlopeCT(pet_gui.SelectedCT));        [~,ROI{val}.RoiSliceNMvsCTindex] = ismember(ROI{val}.RoiSliceNMvsCT,ROI{val}.RoiSlice);    end    n = (length(it)-1)/2+1;    aux1 = max([ceil(p_R(n,1))-10,1]);    aux3 = max([ceil(p_R(n,2))-10,1]);    aux2 = min([floor(p_R(n,1)+2*R(n))+10,512]);    aux4 = min([floor(p_R(n,2)+2*R(n))+10,512]);    [aux1,aux2,aux3,aux4] = Region_Mod4(aux1,aux2,aux3,aux4);    ROI{val}.RoiRegion = [aux1,aux2,aux3,aux4];    set(pet_gui.PANELroi.PANEL3.TXT1b,'string',num2str(ROI{val}.StartCt));    set(pet_gui.PANELroi.PANEL3.TXT2b,'string',num2str(ROI{val}.EndCt));endend